#!/usr/bin/env sh
# Dave McEwan 2023-07-06

# Use `_nrg_depage_BitBucket.sh` list repositories available on the remote,
# printed to STDOUT, whose slugs match an ERE regex.
# Each line features the slug followed, optionally, by the link for SSH access,
# and/or the user-facing name, both separated by one or more space characters.
#
# Environment variable `$BITBUCKET_CREDENTIALS` must be set.
# E.g: `export BITBUCKET_CREDENTIALS=jdoe:XDc1NTkzYjMyODExOrWcTKpzYujz/b/5cQjezElM6+cI`
#
# From BitBucket's documentation:
#   <https://confluence.atlassian.com/bbkb/what-is-a-repository-slug-1168845069.html>
#   A repository slug is a URL-friendly version of a repository name,
#   automatically generated by Bitbucket for use in the URL. For example, if
#   your repository name was "føøbar", in the URL it would become "foobar".
#   Similarly, "foo bar" would become "foo-bar".
# The slug must contain no space characters and be fully lowercase, but the
# user-facing name may contain uppercase characters.


# Fail on uncaught non-zero exit code.
set -e

# The `projectKey` (terminology from BitBucket API) is constant for all
# Nordic's usage of dogit (AFAIK damc 2023-07-12).
# If necessary, the environment variable `$NRG_PROJECTKEY` may be used to
# override the default value.
# The environment variable `$NRG_PROJECTKEY` is sanitized to allow only ASCII
# alpanumericals, underscore, and hyphen characters.
if [ -z "${NRG_PROJECTKEY}" ]
then
  projectKey='SIG-DOGIT'
else
  projectKey="$(echo "${NRG_PROJECTKEY}" | tr -c -d 'A-Za-z0-9_-')"
fi

# Debug mode prints messages to STDERR.
DEBUGMODE=

# Ensure that exactly one line is printed.
# Off by default, overridden by the option -1.
EXACTLYONE=

# Show the SSH link of each repository.
# Off by default, overridden by the option -r.
SHOW_SSH=

# Show the user-facing name of each repository.
# Off by default, overridden by the option -n.
SHOW_NAME=

# Get the sanitized name of this script, used to print usage message and as a
# template for temporary filenames.
# To aid debugging, the sanitized name is found by calling this script with an
# invalid option, such as -h.
THIS="$(echo "$(basename "$0")" | tr -c -d '[a-z_.]')"

# Process the command-line arguments.
# <https://pubs.opengroup.org/onlinepubs/9699919799/utilities/getopts.html>
# First, the optional arguments.
while getopts 'd1rn' OPT
do
  case $OPT in
    d)  DEBUGMODE=1;;
    1)  EXACTLYONE=1;;
    r)  SHOW_SSH=1;;
    n)  SHOW_NAME=1;;
    ?)  printf "Usage: %s [-d] [-1] [-r] [-n] <ERE>\n" ${THIS}
        exit 2;;
  esac
done
# Second, the positional arguments.
shift $(($OPTIND - 1))

# Regex applied to slugs, in POSIX Extended Regular Expression syntax.
# Defaults to the least restrictive, `.*`, matching any slug.
# <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html>
# <https://en.wikipedia.org/wiki/Kleene_star>
if [ -z "$1" ]
then
  RESLUG_PARTIAL='.*'
else
  RESLUG_PARTIAL="$1"
fi

# Fail on encountering an undefined variable.
set -u

# The provided ERE is applied to whole lines output by jq.
# When either the -r or -n options are given, each line contains the slug
# followed by the SSH remote and/or the user-friendly name.
# Therefore the ERE is modified by anchoring to the beginning of the line,
# and either anchoring to the end of the line (with neither -r or -n) or
# terminating on a space character.
# NOTE: This is not infallible as the user can provide an ERE which passes over
# a space, though the added terminating space would not match any line.
# Santitization is not applied to the ERE because it is kept quoted at all
# stages.
if [ -z "${SHOW_SSH}" ] && [ -z "${SHOW_NAME}" ]
then
  RESLUG="^${RESLUG_PARTIAL}\$"
else
  RESLUG="^${RESLUG_PARTIAL} "
fi

if [ ! -z "${DEBUGMODE}" ]
then
  printf "Credentials=%s\n" "${BITBUCKET_CREDENTIALS}" >&2
fi

# BitBucket's REST API uses paging.
# DEPAGE points to a utility which extracts the values into one JSON array,
# i.e. an ordered list of JSON objects.
# <https://www.json.org/json-en.html>
DEPAGE='_nrg_depage_BitBucket.sh'

# Pass the -d option down to `_nrg_depage_BitBucket.sh` which uses it in the
# same way.
if [ ! -z "${DEBUGMODE}" ]
then
  DEPAGE="${DEPAGE} -d"
fi

# NOTE: The -f option to `_nrg_depage_BitBucket.sh` waits until all pages are
# received before returning any output.
# There is no way to set the -f option in this script, so data is processed as
# soon as it is received.

# NOTE: The -u option to `_nrg_depage_BitBucket.sh` allows the user to pass
# credentials on the command line.
# There is no way to set the -u option in this script, so credentials must be
# given with the environment variable `$BITBUCKET_CREDENTIALS`.

# NOTE: The -l option to `_nrg_depage_BitBucket.sh` specifies how many items to
# request from BitBucket with each URI.
# That may be useful for system administrators looking to tune performance,
# however, this should not be changed under normal circumstances.
# Therefore, there is no way to set the -l option in this script.

# NOTE: The -b option to `_nrg_depage_BitBucket.sh` specifies the base URI of
# the BitBucket Git server.
# There is no way to set the -b option in this script, but the environment
# variable `$BITBUCKET_BASEURI` can override the default.
# You may wish to set the `$BITBUCKET_BASEURI` environment variable if, for
# example, Atlassian release an incompatible version of the API, or to
# facilitate an IT systems migration.

# Example of using the `_nrg_depage_BitBucket.sh` script manually:
#   BITBUCKET_CREDENTIALS="jdoe:XDc1NTkzYjMyODExOrWcTKpzYujz/b/5cQjezElM6+cI" \
#     _nrg_depage_BitBucket.sh projects/SIG-DOGIT/repos > values.json

# <https://developer.atlassian.com/server/bitbucket/rest/v810/api-group-repository/#api-api-latest-repos-get>
URI="projects/${projectKey}/repos"


JQ_QUERY='\(.slug | select(contains(" ") | not))'
if [ ! -z "${SHOW_SSH}" ]
then
  JQ_QUERY="${JQ_QUERY} \\(.links.clone[] | select(.name == \"ssh\") | .href)"
  #                    ^
  #                    |
  # The first space matches the final/terminating space in RESLUG.
fi
if [ ! -z "${SHOW_NAME}" ]
then
  JQ_QUERY="${JQ_QUERY} \\(.name)"
  #                    ^
  #                    |
  # The first space matches the final/terminating space in RESLUG.
fi
JQ_QUERY=".[] | \"${JQ_QUERY}\""


if [ ! -z "${DEBUGMODE}" ]
then
  printf "JQ_QUERY=%s\n" "${JQ_QUERY}" >&2
fi


# Use the depager subscript, which puts JSON data on STDOUT as it's received,
# then use `jq` string interpolation to produce one line per repository.
# Those lines are piped into `grep` and filtered using the user-supplied ERE.
# When the -1 option (the number one) is given, the output lines is counted
# using `wc` and exit status is set to non-zero if the number of output lines
# is either zero or more than one.
if [ -z "${EXACTLYONE}" ]
then
  ${DEPAGE} ${URI} \
  | jq -r "${JQ_QUERY}" \
  | grep -Ei "${RESLUG}"
else
  COUNT=$(${DEPAGE} ${URI} \
  | jq -r "${JQ_QUERY}" \
  | grep -Ei "${RESLUG}" \
  | tee /dev/tty | wc -l)

  if [ "${COUNT}" = "1" ]
  then
    exit 0
  else
    if [ ! -z "${DEBUGMODE}" ]
    then
      printf "COUNT=%s\n" "${COUNT}" >&2
    fi
    exit -1
  fi
fi
